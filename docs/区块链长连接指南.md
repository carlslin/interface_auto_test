# 区块链长连接使用指南

## 概述

区块链长连接功能为接口自动化测试框架提供了强大的区块链网络连接管理能力，支持WebSocket长连接、HTTP连接池、事件订阅、心跳监控等高级特性。

## 主要特性

### 1. 长连接管理
- **WebSocket连接**: 支持以太坊、BSC、Polygon等网络的WebSocket连接
- **HTTP连接池**: 高效的HTTP连接池管理，支持并发请求
- **自动重连**: 智能重连机制，支持指数退避算法
- **连接监控**: 实时连接状态监控和健康检查

### 2. 事件订阅
- **实时事件**: 订阅新区块、交易、日志等区块链事件
- **事件过滤**: 支持地址和主题过滤
- **批量处理**: 事件批量处理和异步处理
- **死信队列**: 失败事件的重试和死信队列处理

### 3. 性能优化
- **连接复用**: 高效的连接复用和负载均衡
- **并发处理**: 支持高并发连接和请求处理
- **内存优化**: 智能的内存管理和连接池优化
- **监控集成**: 详细的性能监控和统计信息

## 快速开始

### 1. 基础WebSocket连接

```python
import asyncio
from src.blockchain.connection_manager import BlockchainConnectionManager

async def basic_websocket_connection():
    # 创建连接管理器
    conn_manager = BlockchainConnectionManager()
    
    # 建立WebSocket连接
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    print(f"连接建立成功: {connection_id}")
    
    # 使用连接...
    
    # 断开连接
    await conn_manager.disconnect(connection_id)

# 运行示例
asyncio.run(basic_websocket_connection())
```

### 2. 事件订阅

```python
async def event_subscription():
    conn_manager = BlockchainConnectionManager()
    
    # 建立连接
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    # 订阅新区块事件
    await conn_manager.subscribe_events(connection_id, "newHeads")
    
    # 监听事件
    async for event in conn_manager.listen_events(connection_id):
        if event.get("method") == "eth_subscription":
            params = event.get("params", {})
            result = params.get("result", {})
            
            if "number" in result:
                block_number = int(result["number"], 16)
                print(f"新区块: #{block_number}")
        
        # 限制监听数量
        if event_count >= 10:
            break
    
    await conn_manager.disconnect(connection_id)
```

### 3. HTTP连接池

```python
async def http_connection_pool():
    conn_manager = BlockchainConnectionManager()
    
    # 创建HTTP连接池
    pool_id = await conn_manager.connect_http_pool(
        "https://sepolia.infura.io/v3/YOUR_KEY",
        pool_size=5
    )
    
    # 获取连接池中的连接
    stats = conn_manager.get_connection_stats()
    pool_connections = [conn_id for conn_id in stats["connections"].keys() 
                       if conn_id.startswith(pool_id)]
    
    # 并发发送请求
    tasks = []
    for conn_id in pool_connections:
        task = asyncio.create_task(
            conn_manager.send_request(conn_id, "eth_blockNumber")
        )
        tasks.append(task)
    
    results = await asyncio.gather(*tasks)
    
    for result in results:
        if "result" in result:
            block_number = int(result["result"], 16)
            print(f"当前区块: {block_number}")
    
    # 清理连接池
    for conn_id in pool_connections:
        await conn_manager.disconnect(conn_id)
```

## 高级功能

### 1. 心跳监控

```python
async def heartbeat_monitoring():
    conn_manager = BlockchainConnectionManager()
    
    # 建立连接
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    # 启动心跳监控
    await conn_manager.start_heartbeat_monitoring()
    
    # 监控连接状态
    for i in range(10):
        await asyncio.sleep(5)
        stats = conn_manager.get_connection_stats()
        if connection_id in stats["connections"]:
            conn_info = stats["connections"][connection_id]
            print(f"连接状态: {conn_info['status']}")
    
    # 停止心跳监控
    await conn_manager.stop_heartbeat_monitoring()
    await conn_manager.disconnect(connection_id)
```

### 2. 事件处理器

```python
async def event_handlers():
    conn_manager = BlockchainConnectionManager()
    
    # 添加事件处理器
    def on_new_block(event_data):
        print(f"收到新区块事件: {event_data}")
    
    def on_transaction(event_data):
        print(f"收到交易事件: {event_data}")
    
    conn_manager.add_event_handler("newHeads", on_new_block)
    conn_manager.add_event_handler("logs", on_transaction)
    
    # 建立连接并订阅事件
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    await conn_manager.subscribe_events(connection_id, "newHeads")
    
    # 监听事件（处理器会自动被调用）
    async for event in conn_manager.listen_events(connection_id):
        pass  # 处理器会自动处理事件
```

### 3. 连接配置

```python
from src.blockchain.connection_manager import ConnectionConfig, ConnectionType

async def custom_connection_config():
    conn_manager = BlockchainConnectionManager()
    
    # 自定义连接配置
    config = ConnectionConfig(
        url="wss://sepolia.infura.io/ws/v3/YOUR_KEY",
        connection_type=ConnectionType.WEBSOCKET,
        timeout=60,
        max_retries=10,
        retry_delay=2.0,
        heartbeat_interval=30,
        max_connections=20,
        headers={"User-Agent": "MyApp/1.0"},
        auth=("username", "password")
    )
    
    # 使用自定义配置建立连接
    connection_id = await conn_manager.connect_websocket(
        config.url, config
    )
    
    print(f"自定义配置连接建立成功: {connection_id}")
```

## 网络支持

### 支持的区块链网络

| 网络 | 类型 | WebSocket URL | HTTP URL |
|------|------|---------------|----------|
| Ethereum Sepolia | 测试网 | `wss://sepolia.infura.io/ws/v3/YOUR_KEY` | `https://sepolia.infura.io/v3/YOUR_KEY` |
| BSC Testnet | 测试网 | `wss://bsc-testnet.publicnode.com` | `https://data-seed-prebsc-1-s1.binance.org:8545` |
| Polygon Mumbai | 测试网 | `wss://ws-mumbai.maticvigil.com` | `https://rpc-mumbai.maticvigil.com` |
| Arbitrum Goerli | 测试网 | `wss://goerli-rollup.arbitrum.io/ws` | `https://goerli-rollup.arbitrum.io/rpc` |

### 配置文件使用

```yaml
# config/blockchain.yaml
ethereum:
  sepolia:
    rpc_url: "https://sepolia.infura.io/v3/YOUR_KEY"
    ws_url: "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    chain_id: 11155111
    explorer: "https://sepolia.etherscan.io"
```

```python
from src.blockchain.blockchain_config import BlockchainConfig

# 使用配置文件
config = BlockchainConfig()
network_config = config.get_network_config("ethereum", "sepolia")
ws_url = network_config["ws_url"]
```

## 性能优化

### 1. 连接池优化

```python
async def optimized_connection_pool():
    conn_manager = BlockchainConnectionManager(max_connections=100)
    
    # 创建多个连接池
    pools = []
    for i in range(5):
        pool_id = await conn_manager.connect_http_pool(
            "https://sepolia.infura.io/v3/YOUR_KEY",
            pool_size=20
        )
        pools.append(pool_id)
    
    # 负载均衡请求
    tasks = []
    for i in range(100):
        pool_id = pools[i % len(pools)]
        stats = conn_manager.get_connection_stats()
        pool_connections = [conn_id for conn_id in stats["connections"].keys() 
                           if conn_id.startswith(pool_id)]
        
        conn_id = pool_connections[i % len(pool_connections)]
        task = asyncio.create_task(
            conn_manager.send_request(conn_id, "eth_blockNumber")
        )
        tasks.append(task)
    
    results = await asyncio.gather(*tasks)
    print(f"完成 {len(results)} 个并发请求")
```

### 2. 事件批处理

```python
async def batch_event_processing():
    conn_manager = BlockchainConnectionManager()
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    # 订阅多个事件
    await conn_manager.subscribe_events(connection_id, "newHeads")
    await conn_manager.subscribe_events(connection_id, "logs")
    
    # 批量处理事件
    batch_size = 10
    event_batch = []
    
    async for event in conn_manager.listen_events(connection_id):
        event_batch.append(event)
        
        if len(event_batch) >= batch_size:
            # 批量处理事件
            await process_event_batch(event_batch)
            event_batch = []
    
    await conn_manager.disconnect(connection_id)

async def process_event_batch(events):
    """批量处理事件"""
    print(f"处理 {len(events)} 个事件")
    # 这里可以实现批量处理逻辑
```

## 错误处理

### 1. 连接重试

```python
async def connection_retry():
    conn_manager = BlockchainConnectionManager()
    
    max_retries = 5
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            connection_id = await conn_manager.connect_websocket(
                "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
            )
            print(f"连接成功: {connection_id}")
            break
            
        except Exception as e:
            retry_count += 1
            print(f"连接失败 (重试 {retry_count}/{max_retries}): {e}")
            
            if retry_count < max_retries:
                await asyncio.sleep(2 ** retry_count)  # 指数退避
            else:
                print("连接失败，已达到最大重试次数")
                raise
```

### 2. 异常处理

```python
async def robust_connection_handling():
    conn_manager = BlockchainConnectionManager()
    
    try:
        connection_id = await conn_manager.connect_websocket(
            "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
        )
        
        # 启动心跳监控
        await conn_manager.start_heartbeat_monitoring()
        
        # 监听事件
        async for event in conn_manager.listen_events(connection_id):
            try:
                # 处理事件
                await handle_event(event)
            except Exception as e:
                print(f"事件处理失败: {e}")
                # 继续处理下一个事件
                continue
                
    except KeyboardInterrupt:
        print("用户中断")
    except Exception as e:
        print(f"连接处理失败: {e}")
    finally:
        # 清理资源
        await conn_manager.disconnect_all()

async def handle_event(event):
    """处理单个事件"""
    # 实现事件处理逻辑
    pass
```

## 监控和调试

### 1. 连接统计

```python
async def connection_monitoring():
    conn_manager = BlockchainConnectionManager()
    
    # 建立连接
    connection_id = await conn_manager.connect_websocket(
        "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
    )
    
    # 定期获取统计信息
    for i in range(10):
        await asyncio.sleep(5)
        stats = conn_manager.get_connection_stats()
        
        print(f"统计信息 #{i+1}:")
        print(f"  - 总连接数: {stats['total_connections']}")
        print(f"  - 活跃连接: {stats['active_connections']}")
        print(f"  - 失败连接: {stats['failed_connections']}")
        print(f"  - 总事件数: {stats['total_events']}")
        
        if connection_id in stats['connections']:
            conn_info = stats['connections'][connection_id]
            print(f"  - 连接状态: {conn_info['status']}")
            print(f"  - 最后心跳: {time.time() - conn_info['last_heartbeat']:.1f}s前")
```

### 2. 性能分析

```python
import time
import asyncio

async def performance_analysis():
    conn_manager = BlockchainConnectionManager()
    
    # 性能测试
    start_time = time.time()
    
    # 创建多个连接
    tasks = []
    for i in range(20):
        task = asyncio.create_task(
            conn_manager.connect_websocket(
                "wss://sepolia.infura.io/ws/v3/YOUR_KEY"
            )
        )
        tasks.append(task)
    
    connection_ids = await asyncio.gather(*tasks)
    connection_time = time.time() - start_time
    
    print(f"创建 {len(connection_ids)} 个连接耗时: {connection_time:.2f}秒")
    print(f"平均每个连接: {connection_time/len(connection_ids)*1000:.1f}ms")
    
    # 发送请求性能测试
    start_time = time.time()
    
    request_tasks = []
    for conn_id in connection_ids:
        task = asyncio.create_task(
            conn_manager.send_request(conn_id, "eth_blockNumber")
        )
        request_tasks.append(task)
    
    results = await asyncio.gather(*request_tasks)
    request_time = time.time() - start_time
    
    print(f"发送 {len(results)} 个请求耗时: {request_time:.2f}秒")
    print(f"平均每个请求: {request_time/len(results)*1000:.1f}ms")
    
    # 清理连接
    for conn_id in connection_ids:
        await conn_manager.disconnect(conn_id)
```

## 最佳实践

### 1. 连接管理

```python
class BlockchainService:
    def __init__(self):
        self.conn_manager = BlockchainConnectionManager()
        self.connections = {}
    
    async def get_connection(self, network: str):
        """获取或创建连接"""
        if network not in self.connections:
            config = self.get_network_config(network)
            connection_id = await self.conn_manager.connect_websocket(
                config["ws_url"]
            )
            self.connections[network] = connection_id
        
        return self.connections[network]
    
    async def cleanup(self):
        """清理所有连接"""
        for connection_id in self.connections.values():
            await self.conn_manager.disconnect(connection_id)
        self.connections.clear()
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()

# 使用上下文管理器
async def main():
    async with BlockchainService() as service:
        connection_id = await service.get_connection("sepolia")
        # 使用连接...
```

### 2. 事件处理

```python
class EventProcessor:
    def __init__(self, conn_manager):
        self.conn_manager = conn_manager
        self.event_queue = asyncio.Queue()
        self.processors = {}
    
    def register_processor(self, event_type, processor):
        """注册事件处理器"""
        self.processors[event_type] = processor
    
    async def start_processing(self):
        """启动事件处理"""
        # 启动事件处理任务
        tasks = [
            asyncio.create_task(self.event_consumer()),
            asyncio.create_task(self.event_processor())
        ]
        await asyncio.gather(*tasks)
    
    async def event_consumer(self):
        """事件消费者"""
        # 从连接管理器接收事件并放入队列
        pass
    
    async def event_processor(self):
        """事件处理器"""
        while True:
            try:
                event = await self.event_queue.get()
                event_type = event.get("method")
                
                if event_type in self.processors:
                    await self.processors[event_type](event)
                
                self.event_queue.task_done()
            except Exception as e:
                print(f"事件处理失败: {e}")
```

### 3. 配置管理

```python
class BlockchainConfigManager:
    def __init__(self):
        self.config = BlockchainConfig()
        self.env_overrides = {
            "ETHEREUM_SEPOLIA_WS_URL": "ethereum.sepolia.ws_url",
            "ETHEREUM_SEPOLIA_RPC_URL": "ethereum.sepolia.rpc_url",
            "BSC_TESTNET_WS_URL": "ethereum.bsc_testnet.ws_url"
        }
    
    def get_network_config(self, blockchain: str, network: str):
        """获取网络配置，支持环境变量覆盖"""
        config = self.config.get_network_config(blockchain, network)
        
        # 应用环境变量覆盖
        for env_var, config_path in self.env_overrides.items():
            if env_var.startswith(f"{blockchain.upper()}_{network.upper()}"):
                env_value = os.getenv(env_var)
                if env_value:
                    self._set_nested_config(config, config_path, env_value)
        
        return config
    
    def _set_nested_config(self, config, path, value):
        """设置嵌套配置"""
        keys = path.split('.')
        current = config
        
        for key in keys[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]
        
        current[keys[-1]] = value
```

## 故障排除

### 常见问题

1. **连接超时**
   ```
   错误: Connection timeout
   解决: 检查网络配置，增加超时时间
   ```

2. **WebSocket连接失败**
   ```
   错误: WebSocket connection failed
   解决: 检查WebSocket URL，确保网络可访问
   ```

3. **事件订阅失败**
   ```
   错误: Event subscription failed
   解决: 检查订阅参数，确保连接状态正常
   ```

4. **内存泄漏**
   ```
   问题: 内存使用持续增长
   解决: 确保正确断开连接，使用上下文管理器
   ```

### 调试技巧

```python
import logging

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)

# 添加自定义日志处理器
class ConnectionLogger:
    def __init__(self, conn_manager):
        self.conn_manager = conn_manager
        self.logger = logging.getLogger("ConnectionLogger")
    
    async def monitor_connections(self):
        """监控连接状态"""
        while True:
            stats = self.conn_manager.get_connection_stats()
            self.logger.info(f"连接统计: {stats}")
            await asyncio.sleep(10)
```

## 总结

区块链长连接功能为接口自动化测试框架提供了强大的区块链网络连接管理能力。通过合理使用这些功能，可以实现高效的区块链数据获取、实时事件监听和高并发请求处理。

关键要点：
- 使用连接池提高并发性能
- 合理配置心跳监控和重连机制
- 实现事件批处理和错误处理
- 使用上下文管理器确保资源清理
- 监控连接状态和性能指标

通过本指南，您可以充分利用区块链长连接功能，构建稳定、高效的区块链测试和监控应用。
